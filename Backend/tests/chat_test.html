<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat API æµ‹è¯•é¡µé¢</title>
    <!-- æ³¨æ„ï¼šè¿™æ˜¯æµ‹è¯•é¡µé¢ï¼Œä½¿ç”¨ Tailwind CDN ä»…ç”¨äºå¿«é€Ÿå¼€å‘æµ‹è¯• -->
    <!-- ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨ PostCSS æ’ä»¶æˆ– Tailwind CLI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ç®€å•çš„ faviconï¼Œé¿å… 404 é”™è¯¯ -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ’¬</text></svg>">
    <style>
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* æµå¼æ–‡æœ¬åŠ¨ç”» */
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        .typing-cursor::after {
            content: 'â–Š';
            animation: blink 1s infinite;
            margin-left: 2px;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen">
    <div class="max-w-4xl mx-auto p-4 md:p-6 lg:p-8">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <h1 class="text-2xl font-bold text-slate-900 mb-2">Chat API æµ‹è¯•é¡µé¢</h1>
            <p class="text-slate-600 text-sm">æµ‹è¯•æ™ºèƒ½å¯¹è¯æ¥å£ï¼Œæ”¯æŒæ–‡å­—å’Œå¤šå›¾ç‰‡ä¸Šä¼ </p>
            
            <!-- é…ç½®åŒºåŸŸ -->
            <div class="mt-4 p-4 bg-slate-50 rounded-lg border border-gray-200">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-1">API åœ°å€</label>
                        <input 
                            type="text" 
                            id="apiUrl" 
                            value="http://localhost:8000" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        />
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-1">Token (alice123)</label>
                        <input 
                            type="text" 
                            id="token" 
                            value="alice123" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        />
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-4">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="streamMode" checked class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <span class="ml-2 text-sm text-slate-700">æµå¼å“åº” (SSE)</span>
                    </label>
                    <button 
                        id="clearChatBtn"
                        class="px-3 py-1 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded transition-colors duration-200 cursor-pointer"
                    >
                        æ¸…é™¤å¯¹è¯
                    </button>
                    <button 
                        id="testConnectionBtn"
                        class="px-3 py-1 text-sm text-blue-600 hover:text-blue-900 hover:bg-blue-50 rounded transition-colors duration-200 cursor-pointer"
                    >
                        æµ‹è¯•è¿æ¥
                    </button>
                </div>
            </div>
        </div>

        <!-- èŠå¤©åŒºåŸŸ -->
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 flex flex-col" style="height: 600px;">
            <!-- æ¶ˆæ¯åˆ—è¡¨ -->
            <div id="messages" class="flex-1 overflow-y-auto p-4 custom-scrollbar space-y-4">
                <div class="text-center text-slate-400 text-sm py-8">
                    å¼€å§‹å¯¹è¯...
                </div>
            </div>

            <!-- è¾“å…¥åŒºåŸŸ -->
            <div class="border-t border-gray-200 p-4">
                <!-- æ–‡ä»¶ä¸Šä¼  -->
                <div class="mb-3">
                    <label class="block text-sm font-medium text-slate-700 mb-2">ä¸Šä¼ å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé€‰ï¼‰</label>
                    <div class="flex items-center gap-2">
                        <input 
                            type="file" 
                            id="fileInput" 
                            multiple 
                            accept="image/*" 
                            class="hidden"
                        />
                        <button 
                            id="selectFileBtn"
                            class="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-md text-sm font-medium transition-colors duration-200 cursor-pointer"
                        >
                            é€‰æ‹©å›¾ç‰‡
                        </button>
                        <div id="fileList" class="flex-1 flex flex-wrap gap-2"></div>
                    </div>
                </div>

                <!-- æ–‡æœ¬è¾“å…¥ -->
                <div class="flex gap-2">
                    <textarea 
                        id="messageInput" 
                        placeholder="è¾“å…¥æ¶ˆæ¯..." 
                        rows="2"
                        class="flex-1 px-4 py-2 border border-gray-300 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    ></textarea>
                    <button 
                        id="sendBtn"
                        class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium transition-colors duration-200 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        å‘é€
                    </button>
                </div>
            </div>
        </div>

        <!-- çŠ¶æ€æ  -->
        <div id="statusBar" class="mt-4 text-sm text-slate-500 text-center"></div>
    </div>

    <script>
        let sessionId = null;
        let selectedFiles = [];

        // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
        function initEventListeners() {
            // ç»‘å®šæ–‡ä»¶é€‰æ‹©äº‹ä»¶
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // ç»‘å®šé€‰æ‹©æ–‡ä»¶æŒ‰é’®
            document.getElementById('selectFileBtn').addEventListener('click', function() {
                document.getElementById('fileInput').click();
            });
            
            // ç»‘å®šå‘é€æŒ‰é’®
            document.getElementById('sendBtn').addEventListener('click', sendMessage);
            
            // ç»‘å®šæµ‹è¯•è¿æ¥æŒ‰é’®
            document.getElementById('testConnectionBtn').addEventListener('click', testConnection);
            
            // ç»‘å®šæ¸…é™¤å¯¹è¯æŒ‰é’®
            document.getElementById('clearChatBtn').addEventListener('click', clearChat);
            
            // ç»‘å®šé”®ç›˜äº‹ä»¶ - å›è½¦å‘é€æ¶ˆæ¯
            document.getElementById('messageInput').addEventListener('keydown', handleKeyDown);
            
            console.log('Event listeners initialized');
        }

        // é¡µé¢åŠ è½½å®Œæˆåç»‘å®šäº‹ä»¶å¤„ç†å™¨
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEventListeners);
        } else {
            // DOM å·²ç»åŠ è½½å®Œæˆï¼Œç›´æ¥åˆå§‹åŒ–
            initEventListeners();
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            
            // è¿‡æ»¤æ‰ç©ºæ–‡ä»¶å’Œæ— æ•ˆæ–‡ä»¶
            const validFiles = files.filter(file => {
                if (!file || !file.name) {
                    console.warn('è·³è¿‡æ— æ•ˆæ–‡ä»¶');
                    return false;
                }
                if (file.size === 0) {
                    console.warn(`è·³è¿‡ç©ºæ–‡ä»¶: ${file.name}`);
                    return false;
                }
                if (!file.type.startsWith('image/')) {
                    console.warn(`è·³è¿‡éå›¾ç‰‡æ–‡ä»¶: ${file.name} (${file.type})`);
                    return false;
                }
                return true;
            });
            
            if (validFiles.length < files.length) {
                const skippedCount = files.length - validFiles.length;
                alert(`å·²è·³è¿‡ ${skippedCount} ä¸ªæ— æ•ˆæ–‡ä»¶ï¼ˆç©ºæ–‡ä»¶æˆ–éå›¾ç‰‡æ ¼å¼ï¼‰`);
            }
            
            if (validFiles.length === 0) {
                // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ–‡ä»¶ï¼Œæ¸…ç©º input
                event.target.value = '';
                return;
            }
            
            selectedFiles = validFiles;
            updateFileList();
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'flex items-center gap-2 px-3 py-1 bg-blue-50 text-blue-700 rounded-md text-sm';
                fileItem.innerHTML = `
                    <span>${file.name}</span>
                    <button 
                        class="remove-file-btn text-blue-600 hover:text-blue-800 cursor-pointer"
                        data-index="${index}"
                    >Ã—</button>
                `;
                // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
                fileItem.querySelector('.remove-file-btn').addEventListener('click', function() {
                    removeFile(parseInt(this.getAttribute('data-index')));
                });
                fileList.appendChild(fileItem);
            });
        }

        // ç§»é™¤æ–‡ä»¶
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFileList();
            // æ›´æ–° input å…ƒç´ 
            const input = document.getElementById('fileInput');
            const dt = new DataTransfer();
            selectedFiles.forEach(file => dt.items.add(file));
            input.files = dt.files;
        }

        // å¤„ç†é”®ç›˜äº‹ä»¶
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const token = document.getElementById('token').value.trim();
            const streamMode = document.getElementById('streamMode').checked;

            // éªŒè¯ï¼šå¿…é¡»æœ‰æ¶ˆæ¯æˆ–æ–‡ä»¶
            if (!message && selectedFiles.length === 0) {
                alert('è¯·è¾“å…¥æ¶ˆæ¯æˆ–é€‰æ‹©å›¾ç‰‡');
                return;
            }

            // éªŒè¯ï¼šAPI åœ°å€å’Œ Token ä¸èƒ½ä¸ºç©º
            if (!apiUrl) {
                alert('è¯·è¾“å…¥ API åœ°å€');
                return;
            }
            if (!token) {
                alert('è¯·è¾“å…¥ Token');
                return;
            }

            // ç¦ç”¨å‘é€æŒ‰é’®
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'å‘é€ä¸­...';

            // ä¿å­˜æ–‡ä»¶å¼•ç”¨ï¼ˆåœ¨æ¸…ç©ºå‰ï¼‰
            const filesToProcess = [...selectedFiles];
            const hasFiles = filesToProcess.length > 0;

            // éªŒè¯æ–‡ä»¶æ˜¯å¦æœ‰æ•ˆ
            if (hasFiles) {
                for (const file of filesToProcess) {
                    if (!file || !file.name) {
                        alert('æ£€æµ‹åˆ°æ— æ•ˆçš„æ–‡ä»¶ï¼Œè¯·é‡æ–°é€‰æ‹©');
                        sendBtn.disabled = false;
                        sendBtn.textContent = 'å‘é€';
                        return;
                    }
                    if (file.size === 0) {
                        alert(`æ–‡ä»¶ "${file.name}" ä¸ºç©ºï¼Œè¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶`);
                        sendBtn.disabled = false;
                        sendBtn.textContent = 'å‘é€';
                        return;
                    }
                    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
                    if (!file.type.startsWith('image/')) {
                        alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼ï¼Œè¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶`);
                        sendBtn.disabled = false;
                        sendBtn.textContent = 'å‘é€';
                        return;
                    }
                }
            }

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            addMessage('user', message || (hasFiles ? `ä¸Šä¼ äº† ${filesToProcess.length} å¼ å›¾ç‰‡` : ''), hasFiles ? `${filesToProcess.length} å¼ å›¾ç‰‡` : null);

            // æ¸…ç©ºè¾“å…¥
            messageInput.value = '';
            selectedFiles = [];
            updateFileList();
            document.getElementById('fileInput').value = '';

            try {
                // è½¬æ¢å›¾ç‰‡ä¸º base64
                const imagesBase64 = [];
                for (const file of filesToProcess) {
                    try {
                        const base64 = await fileToBase64(file);
                        if (base64 && base64.length > 0) {
                            imagesBase64.push(base64);
                        } else {
                            console.warn(`æ–‡ä»¶ ${file.name} è½¬æ¢å¤±è´¥ï¼ˆbase64 ä¸ºç©ºï¼‰`);
                        }
                    } catch (error) {
                        console.error(`æ–‡ä»¶ ${file.name} è½¬æ¢é”™è¯¯:`, error);
                        addMessage('error', `æ–‡ä»¶ "${file.name}" å¤„ç†å¤±è´¥: ${error.message}`);
                    }
                }

                // å¦‚æœæ²¡æœ‰æˆåŠŸè½¬æ¢ä»»ä½•å›¾ç‰‡ï¼Œä¸”æ²¡æœ‰æ¶ˆæ¯ï¼Œåˆ™æŠ¥é”™
                if (imagesBase64.length === 0 && !message) {
                    addMessage('error', 'æ²¡æœ‰æœ‰æ•ˆçš„å›¾ç‰‡æˆ–æ¶ˆæ¯');
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'å‘é€';
                    return;
                }

                // æ„å»ºè¯·æ±‚ä½“
                const requestBody = {
                    message: message || (imagesBase64.length > 0 ? 'è¯·åˆ†æè¿™äº›å›¾ç‰‡' : ''),
                    session_id: sessionId,
                };

                if (imagesBase64.length > 0) {
                    if (imagesBase64.length === 1) {
                        requestBody.image_base64 = imagesBase64[0];
                    } else {
                        requestBody.images_base64 = imagesBase64;
                    }
                }

                if (streamMode) {
                    // æµå¼å“åº”
                    await sendStreamRequest(apiUrl, token, requestBody);
                } else {
                    // éæµå¼å“åº”
                    await sendNormalRequest(apiUrl, token, requestBody);
                }
            } catch (error) {
                console.error('Send message error:', error);
                addMessage('error', `é”™è¯¯: ${error.message}`);
                updateStatus(`é”™è¯¯: ${error.message}`);
            } finally {
                sendBtn.disabled = false;
                sendBtn.textContent = 'å‘é€';
            }
        }

        // æ–‡ä»¶è½¬ base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // ç§»é™¤ data:image/...;base64, å‰ç¼€ï¼Œåªä¿ç•™ base64 æ•°æ®
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // å‘é€æµå¼è¯·æ±‚
        async function sendStreamRequest(apiUrl, token, requestBody) {
            const url = `${apiUrl}/api/chat?stream=true`;
            console.log('Sending stream request to:', url);
            console.log('Request body:', JSON.stringify(requestBody, null, 2));
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                });

                console.log('Response status:', response.status, response.statusText);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                if (!response.body) {
                    throw new Error('Response body is null');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullResponse = '';
                let intent = '';
                let messageElement = null;

                console.log('Starting to read stream...');

                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        console.log('Stream finished, remaining buffer:', buffer);
                        // å¤„ç†å‰©ä½™ç¼“å†²åŒº
                        if (buffer.trim()) {
                            if (buffer.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(buffer.substring(6));
                                    console.log('Final buffer data:', data);
                                    processSSEData(data);
                                } catch (e) {
                                    console.error('Final parse error:', e, buffer);
                                }
                            }
                        }
                        break;
                    }
                    
                    const chunk = decoder.decode(value, { stream: true });
                    console.log('Received chunk:', chunk.substring(0, 100));
                    buffer += chunk;
                    
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // ä¿ç•™æœ€åä¸€ä¸ªä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                console.log('SSE event:', data);
                                
                                switch (data.type) {
                                    case 'status':
                                        updateStatus(data.message);
                                        break;
                                    case 'intent':
                                        intent = data.intent;
                                        updateStatus(`æ„å›¾: ${intent}`);
                                        if (!messageElement) {
                                            messageElement = addMessage('assistant', '', null, true);
                                        }
                                        break;
                                    case 'token':
                                        // å¦‚æœè¿˜æ²¡æœ‰åˆ›å»ºæ¶ˆæ¯å…ƒç´ ï¼Œå…ˆåˆ›å»º
                                        if (!messageElement) {
                                            messageElement = addMessage('assistant', '', null, true);
                                        }
                                        fullResponse += data.token;
                                        messageElement.querySelector('.message-content').textContent = fullResponse;
                                        messageElement.querySelector('.message-content').classList.add('typing-cursor');
                                        break;
                                    case 'content':
                                        // ä¸€æ¬¡æ€§è¿”å›å®Œæ•´å†…å®¹
                                        if (!messageElement) {
                                            messageElement = addMessage('assistant', data.content || data.message || '', null, false);
                                        } else {
                                            messageElement.querySelector('.message-content').textContent = data.content || data.message || '';
                                        }
                                        break;
                                    case 'action':
                                        if (data.action_result) {
                                            addMessage('system', `æ“ä½œç»“æœ: ${JSON.stringify(data.action_result, null, 2)}`);
                                        }
                                        break;
                                    case 'done':
                                        // å¦‚æœæœ‰ message å­—æ®µï¼Œæ˜¾ç¤ºå®ƒ
                                        if (data.message && !fullResponse) {
                                            if (!messageElement) {
                                                messageElement = addMessage('assistant', data.message, null, false);
                                            } else {
                                                messageElement.querySelector('.message-content').textContent = data.message;
                                            }
                                        }
                                        if (messageElement) {
                                            messageElement.querySelector('.message-content').classList.remove('typing-cursor');
                                        }
                                        if (data.session_id) {
                                            sessionId = data.session_id;
                                        }
                                        updateStatus('å®Œæˆ');
                                        break;
                                    case 'error':
                                        addMessage('error', `é”™è¯¯: ${data.error}`);
                                        updateStatus('é”™è¯¯');
                                        break;
                                    default:
                                        // å¤„ç†æœªçŸ¥ç±»å‹ï¼Œå¯èƒ½åŒ…å« message å­—æ®µ
                                        console.log('Unknown event type:', data.type, data);
                                        if (data.message && !messageElement) {
                                            messageElement = addMessage('assistant', data.message, null, false);
                                        }
                                        break;
                                }
                            } catch (e) {
                                console.error('Parse error:', e, line);
                            }
                        }
                    }
                }

                // ç§»é™¤å…‰æ ‡åŠ¨ç”»
                if (messageElement) {
                    messageElement.querySelector('.message-content').classList.remove('typing-cursor');
                }
            } catch (error) {
                console.error('Stream request error:', error);
                updateStatus(`æµå¼å“åº”é”™è¯¯: ${error.message}`);
                addMessage('error', `æµå¼å“åº”é”™è¯¯: ${error.message}`);
                throw error;
            }
        }

        // å‘é€æ™®é€šè¯·æ±‚
        async function sendNormalRequest(apiUrl, token, requestBody) {
            updateStatus('å‘é€ä¸­...');

            const url = `${apiUrl}/api/chat`;
            console.log('Sending request to:', url);
            console.log('Request body:', JSON.stringify(requestBody, null, 2));

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                });

                console.log('Response status:', response.status, response.statusText);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                
                addMessage('assistant', data.message, null);
                if (data.intent) {
                    updateStatus(`æ„å›¾: ${data.intent}`);
                }
                if (data.action_result) {
                    addMessage('system', `æ“ä½œç»“æœ: ${JSON.stringify(data.action_result, null, 2)}`);
                }
                if (data.session_id) {
                    sessionId = data.session_id;
                }
                updateStatus('å®Œæˆ');
            } catch (error) {
                console.error('Normal request error:', error);
                updateStatus(`è¯·æ±‚é”™è¯¯: ${error.message}`);
                addMessage('error', `è¯·æ±‚é”™è¯¯: ${error.message}`);
                throw error;
            }
        }

        // æ·»åŠ æ¶ˆæ¯
        function addMessage(role, content, imageInfo = null, isStreaming = false) {
            const messagesDiv = document.getElementById('messages');
            
            // ç§»é™¤"å¼€å§‹å¯¹è¯"æç¤º
            const emptyMsg = messagesDiv.querySelector('.text-center');
            if (emptyMsg) {
                emptyMsg.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'}`;
            
            let bgColor = 'bg-blue-50';
            let textColor = 'text-blue-900';
            if (role === 'user') {
                bgColor = 'bg-blue-600';
                textColor = 'text-white';
            } else if (role === 'error') {
                bgColor = 'bg-red-50';
                textColor = 'text-red-900';
            } else if (role === 'system') {
                bgColor = 'bg-yellow-50';
                textColor = 'text-yellow-900';
            }

            // ä½¿ç”¨ SVG å›¾æ ‡è€Œä¸æ˜¯ emoji
            const imageIcon = imageInfo ? `
                <div class="text-xs opacity-75 mb-1 flex items-center gap-1">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                    </svg>
                    <span>${imageInfo}</span>
                </div>
            ` : '';
            
            messageDiv.innerHTML = `
                <div class="max-w-[80%] ${bgColor} ${textColor} rounded-lg px-4 py-2 shadow-sm">
                    ${imageIcon}
                    <div class="message-content whitespace-pre-wrap">${escapeHtml(content)}</div>
                </div>
            `;

            messagesDiv.appendChild(messageDiv);
            messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });

            return messageDiv;
        }

        // HTML è½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(status) {
            document.getElementById('statusBar').textContent = status;
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const token = document.getElementById('token').value.trim();

            if (!apiUrl) {
                alert('è¯·è¾“å…¥ API åœ°å€');
                return;
            }
            if (!token) {
                alert('è¯·è¾“å…¥ Token');
                return;
            }

            updateStatus('æµ‹è¯•è¿æ¥ä¸­...');

            try {
                // æµ‹è¯•å¥åº·æ£€æŸ¥ç«¯ç‚¹
                const healthResponse = await fetch(`${apiUrl}/api/health`);
                console.log('Health check:', healthResponse.status, healthResponse.statusText);
                
                if (!healthResponse.ok) {
                    throw new Error(`å¥åº·æ£€æŸ¥å¤±è´¥: ${healthResponse.status}`);
                }

                // æµ‹è¯•ç”¨æˆ·ä¿¡æ¯ç«¯ç‚¹
                const userResponse = await fetch(`${apiUrl}/api/user/me`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    },
                });
                console.log('User check:', userResponse.status, userResponse.statusText);

                if (!userResponse.ok) {
                    const errorText = await userResponse.text();
                    throw new Error(`è®¤è¯å¤±è´¥: ${userResponse.status} - ${errorText}`);
                }

                const userData = await userResponse.json();
                console.log('User data:', userData);
                
                updateStatus('è¿æ¥æˆåŠŸï¼');
                alert(`è¿æ¥æˆåŠŸï¼\nç”¨æˆ·: ${userData.username || 'æœªçŸ¥'}\nå¥åº·æ£€æŸ¥: OK`);
            } catch (error) {
                console.error('Connection test error:', error);
                updateStatus(`è¿æ¥å¤±è´¥: ${error.message}`);
                alert(`è¿æ¥å¤±è´¥: ${error.message}`);
            }
        }

        // æ¸…é™¤å¯¹è¯
        async function clearChat() {
            if (!sessionId) {
                alert('æ²¡æœ‰æ´»åŠ¨ä¼šè¯');
                return;
            }

            const apiUrl = document.getElementById('apiUrl').value.trim();
            const token = document.getElementById('token').value.trim();

            try {
                const response = await fetch(`${apiUrl}/api/chat/${sessionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    },
                });

                if (response.ok) {
                    sessionId = null;
                    document.getElementById('messages').innerHTML = `
                        <div class="text-center text-slate-400 text-sm py-8">
                            å¯¹è¯å·²æ¸…é™¤
                        </div>
                    `;
                    updateStatus('å¯¹è¯å·²æ¸…é™¤');
                } else {
                    alert('æ¸…é™¤å¤±è´¥');
                }
            } catch (error) {
                alert(`é”™è¯¯: ${error.message}`);
            }
        }
    </script>
</body>
</html>
